# Raspberry Pi 3 AMP Portierung - Projekt-Zusammenfassung

## ğŸ¯ Projekt-Ziel

**Portierung von TImada's Raspberry Pi 4 OpenAMP/FreeRTOS-Projekt auf Raspberry Pi 3**

Wir portieren eine moderne AMP (Asymmetric Multiprocessing) Implementierung, die ermÃ¶glicht:
- **Linux lÃ¤uft auf CPU Core 0-2**
- **Bare-Metal/FreeRTOS Code lÃ¤uft auf CPU Core 3**
- **Kommunikation via OpenAMP/RPMsg** (Industry Standard)

---

## ğŸ” Was ist AMP?

**Asymmetric Multiprocessing** = Verschiedene Betriebssysteme/Software auf verschiedenen CPU-Kernen

### Unser konkreter Use-Case:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Core 0    â”‚   Core 1    â”‚   Core 2    â”‚    Core 3    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚             â”‚             â”‚             â”‚              â”‚
â”‚    Linux    â”‚    Linux    â”‚    Linux    â”‚  Bare-Metal  â”‚
â”‚   (Master)  â”‚             â”‚             â”‚   (Remote)   â”‚
â”‚             â”‚             â”‚             â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ OpenAMP/RPMsg â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  (Shared Memory IPC)
```

### Warum AMP?
- **Real-Time** auf Bare-Metal Core (keine Linux Latenz)
- **Linux Features** auf anderen Cores (Networking, USB, etc.)
- **Best of Both Worlds**: RT-Performance + Linux-Komfort

---

## ğŸ“š Hintergrund & Kontext

### Ursprung
- **TImada** hat 2020 eine Implementierung fÃ¼r **Raspberry Pi 4** erstellt
- Basiert auf **OpenAMP v2020.04** (Industry Standard)
- Nutzt **FreeRTOS** + **Linux** mit **RPMsg** Kommunikation

### Unsere Aufgabe
- **Portierung auf Raspberry Pi 3** (BCM2837)
- RPi3 hat andere Hardware-Details als RPi4
- Wir mÃ¼ssen Hardware-spezifischen Code anpassen

---

## ğŸ”§ Technische Details

### Hardware-Unterschiede RPi3 vs RPi4

| Feature | **RPi3 (BCM2837)** | **RPi4 (BCM2711)** |
|---------|-------------------|-------------------|
| **CPU** | Cortex-A53 @ 1.2 GHz | Cortex-A72 @ 1.5 GHz |
| **Peripheral Base** | `0x3F000000` | `0xFE000000` |
| **ARM Local Base** | `0x40000000` | `0xFF800000` |
| **Interrupt Controller** | ARM Local IRQ | GIC-400 |
| **ACT LED** | I2C GPIO Expander | GPIO Control mÃ¶glich |

### Kritische Komponenten

#### 1. **libmetal** (Hardware Abstraction Layer)
```
Muss portiert werden:
- System Init (sys.c)
- MMIO Operations (io.c)
- Interrupt Handling (irq.c)
- Cache Management

Ã„nderungen:
- Peripheral Base: 0x3F000000
- ARM Local: 0x40000000
- Kein GIC â†’ ARM Local Interrupts
```

#### 2. **OpenAMP** (Communication Framework)
```
Muss portiert werden:
- platform_info.c (Mailbox, Memory)
- Resource Table
- remoteproc ops

Ã„nderungen:
- Mailbox-Adressen fÃ¼r BCM2837
- Memory Map
- Interrupt-Routing
```

#### 3. **Memory Map**
```
0x00000000 - 0x1FFFFFFF  |  512 MB  | Linux (mem=512M)
0x20000000 - 0x209FFFFF  |   10 MB  | Bare-Metal Code/Data
0x20A00000 - 0x20BFFFFF  |    2 MB  | Shared Memory (IPC)
0x3F000000 - 0x3FFFFFFF  |   16 MB  | BCM2837 Peripherals
0x40000000 - 0x40000FFF  |    4 KB  | ARM Local (Mailboxes!)
```

#### 4. **Mailbox-System** (WICHTIG!)

**Zwei verschiedene Mailbox-Systeme:**

A. **ARM Local Mailboxes** (Core-to-Core IPC)
```
Base: 0x40000000
Core 3 Mailbox 3 SET: 0x400000B0
Core 3 Mailbox 3 CLR: 0x400000F0

â†’ FÃ¼r OpenAMP/RPMsg: âœ… DAS NUTZEN WIR
```

B. **GPU Property Mailbox** (ARM â†” VideoCore)
```
Base: 0x3F00B880
â†’ FÃ¼r ACT LED Control (komplex)
â†’ NICHT fÃ¼r AMP benÃ¶tigt
```

---

## ğŸš¨ Entdeckte Probleme & LÃ¶sungen

### Problem #1: ACT LED (KRITISCH!)
**âŒ Problem:** ACT LED auf RPi3 ist NICHT direkt Ã¼ber GPIO 47 steuerbar
- LED sitzt am I2C GPIO Expander
- Nur via GPU Mailbox Property Interface steuerbar

**âœ… LÃ¶sung:** Externe LED auf GPIO 17 verwenden
```c
#define TEST_LED_PIN  17  // Physical Pin 11
// Hardware: GPIO 17 â†’ 330Î© â†’ LED â†’ GND
```

### Problem #2: Cache Coherency
**âŒ Problem:** Cortex-A53 hat keine HW Cache Coherency ohne SCU
- Shared Memory MUSS cache-coherent sein!

**âœ… LÃ¶sung:** 
- Option 1: Shared Memory als UNCACHED markieren (MMU)
- Option 2: Manuelle Cache Flush/Invalidate

```c
void flush_dcache_range(void *addr, size_t size) {
    for (uintptr_t va = start; va < end; va += 64) {
        asm volatile("dc cvac, %0" : : "r"(va));
    }
    asm volatile("dsb sy");
}
```

### Problem #3: Memory Overlap
**âŒ Problem:** Linux kÃ¶nnte in Bare-Metal Memory schreiben

**âœ… LÃ¶sung:** Device Tree + cmdline.txt
```dts
reserved-memory {
    amp_reserved@20000000 {
        compatible = "shared-dma-pool";
        reg = <0x20000000 0x1000000>;  // 16 MB
        no-map;  // â† KRITISCH!
    };
};
```
```bash
# cmdline.txt
maxcpus=3 mem=512M
```

---

## ğŸ“‹ Projekt-Struktur

### Repositories (Referenz)
```
~/rpi3_amp_project/
â”œâ”€â”€ rpi4_ref/                    # TImada's RPi4 Original
â”œâ”€â”€ rpi4_rpmsg_ref/              # TImada's RPi4 RPMSG
â””â”€â”€ rpi3_amp/                    # UNSER NEUES PROJEKT
    â”œâ”€â”€ libmetal_rpi3/           # Portierte libmetal
    â”‚   â””â”€â”€ lib/system/freertos/raspi3/
    â”‚       â”œâ”€â”€ sys.c            # System Init
    â”‚       â”œâ”€â”€ io.c             # MMIO
    â”‚       â”œâ”€â”€ irq.c            # Interrupts
    â”‚       â””â”€â”€ cache.c          # Cache Mgmt
    â”œâ”€â”€ open-amp_rpi3/           # Portierte OpenAMP
    â”‚   â””â”€â”€ apps/machine/raspi3/
    â”‚       â”œâ”€â”€ platform_info.c  # Platform specifics
    â”‚       â””â”€â”€ rsc_table.c      # Resource Table
    â”œâ”€â”€ samples/
    â”‚   â”œâ”€â”€ freertos/            # FreeRTOS/Bare-Metal Code
    â”‚   â””â”€â”€ linux/               # Linux Userspace
    â””â”€â”€ dts/
        â””â”€â”€ raspi3-amp.dtso      # Device Tree Overlay
```

### Kritische Dateien zum Portieren

1. **libmetal/lib/system/freertos/raspi3/sys.c**
   - Peripheral Base Ã¤ndern: `0x3F000000`
   - ARM Local Base Ã¤ndern: `0x40000000`
   - Mailbox-Offsets anpassen

2. **open-amp/apps/machine/raspi3/platform_info.c**
   - Mailbox-Funktionen (Core 0 â†” Core 3)
   - Shared Memory Mapping
   - Interrupt-Handling (ARM Local statt GIC)

3. **dts/raspi3-amp.dtso**
   - Reserved Memory
   - UIO Devices
   - CPU Core 3 isolieren

---

## ğŸ—“ï¸ Projekt-Plan (4 Wochen)

### **Week 1: Grundlagen & Erste Tests**
- Tag 1-2: Development Setup, LED Blink Test
- Tag 3: Device Tree, Linux mit 3 Cores
- Tag 4-5: libmetal Basis-Portierung
- Tag 6-7: OpenAMP platform_info.c

**Ziel Week 1:** 
- âœ… Externe LED blinkt auf Core 3
- âœ… Linux bootet mit 3 Cores
- âœ… Mailbox Write/Read funktioniert

### **Week 2: OpenAMP Integration**
- libmetal vollstÃ¤ndig portieren
- OpenAMP remoteproc implementieren
- RPMsg Channels aufbauen
- Erste IPC-Tests

**Ziel Week 2:**
- âœ… OpenAMP initialisiert
- âœ… RPMsg Ping-Pong funktioniert

### **Week 3-4: StabilitÃ¤t & Performance**
- Cache-Coherency perfektionieren
- Performance-Tuning
- Umfangreiche Tests
- Dokumentation

**Ziel Week 3-4:**
- âœ… Stabile IPC (>1000 msg/sec)
- âœ… Dokumentiert & reproduzierbar
- âœ… GitHub Repository verÃ¶ffentlichen

---

## ğŸ› ï¸ Development Environment

### BenÃ¶tigte Tools
```bash
# Cross-Compiler
arm-gnu-toolchain-13.2.rel1-x86_64-aarch64-none-elf

# Build Tools
cmake >= 3.10
make
device-tree-compiler (dtc)

# Debugging
minicom / screen (UART)
gdb-multiarch (optional)
```

### Hardware Setup
```
Raspberry Pi 3 Model B
â”œâ”€â”€ USB-UART Adapter
â”‚   â”œâ”€â”€ GPIO 14 (Pin 8)  â†’ UART RX
â”‚   â”œâ”€â”€ GPIO 15 (Pin 10) â†’ UART TX
â”‚   â””â”€â”€ GND (Pin 6)      â†’ GND
â”‚
â””â”€â”€ Test LED
    â”œâ”€â”€ GPIO 17 (Pin 11) â†’ 330Î© Resistor
    â”œâ”€â”€ Resistor         â†’ LED Anode (+)
    â”œâ”€â”€ LED Cathode (-)  â†’ GND (Pin 6)
    â””â”€â”€ [LED blinkt = Code lÃ¤uft!]
```

---

## ğŸ“– Wichtige Konzepte

### 1. **OpenAMP Framework**
Standard fÃ¼r AMP-Systeme, bestehend aus:
- **remoteproc**: Lifecycle Management (Load, Start, Stop Firmware)
- **RPMsg**: Message Passing (IPC)
- **virtio**: Transport Layer (Ring Buffers)

### 2. **Resource Table**
Datenstruktur in Bare-Metal Firmware:
```c
struct remote_resource_table {
    uint32_t version;          // = 1
    uint32_t num;              // Anzahl Ressourcen
    uint32_t offset[2];        // Offsets zu Ressourcen
    
    struct fw_rsc_vdev vdev;   // virtio Device
    struct fw_rsc_vdev_vring vring0;  // TX Ring
    struct fw_rsc_vdev_vring vring1;  // RX Ring
};
```
- Linux liest diese Tabelle
- Richtet Shared Memory ein
- Erstellt RPMsg Channels

### 3. **VirtIO Rings**
Shared Memory Ring Buffers fÃ¼r IPC:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VRING 0 (TX)   â”‚  Core 3 â†’ Core 0
â”‚  @ 0x20A10000    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   VRING 1 (RX)   â”‚  Core 0 â†’ Core 3
â”‚  @ 0x20A20000    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. **Mailbox-basierte Interrupts**
Core 3 signalisiert Linux via Mailbox:
```c
// Core 3: Send Signal to Core 0
volatile uint32_t *mbox = (uint32_t*)0x40000080;  // Core 0 MB3
*mbox = 1;
asm volatile("sev");  // Send Event

// Core 0: EmpfÃ¤ngt Mailbox IRQ
// â†’ ruft OpenAMP notify handler auf
// â†’ liest Daten aus VirtIO Ring
```

---

## ğŸ¯ Erfolgs-Kriterien

### Minimum Viable Product (MVP)
- âœ… Linux bootet auf Core 0-2
- âœ… Bare-Metal lÃ¤uft auf Core 3
- âœ… Ping-Pong Message via RPMsg

### Full Success
- âœ… Bidirektionale RPMsg Kommunikation
- âœ… Performance: >1000 Messages/sec
- âœ… Stabil Ã¼ber Stunden
- âœ… Cache-Coherent Shared Memory
- âœ… Reproduzierbar dokumentiert

---

## ğŸ“š Wichtige Dokumentationen

### Hardware
1. **BCM2835 ARM Peripherals** (gilt auch fÃ¼r BCM2837!)
   - GPIO, UART, SPI, I2C, Timers
   - URL: raspberrypi.org/documentation

2. **BCM2836 QA7 - ARM Local Peripherals**
   - Mailboxes! (KRITISCH)
   - Local Interrupts
   - Local Timers

3. **ARM Cortex-A53 MPCore TRM**
   - Multiprocessing
   - Cache Coherency
   - SCU (Snoop Control Unit)

4. **ARMv8-A Architecture Reference Manual**
   - Exception Levels
   - MMU
   - Cache Operations

### Software
5. **OpenAMP Documentation**
   - openamp.readthedocs.io
   - remoteproc Framework
   - RPMsg Protocol

6. **libmetal Documentation**
   - HAL API
   - System Porting Guide

---

## ğŸ”— Wichtige Links & Ressourcen

### Code-Referenzen
- **TImada RPi4:** https://github.com/TImada/raspi4_freertos_rpmsg
- **OpenAMP:** https://github.com/OpenAMP/open-amp
- **libmetal:** https://github.com/OpenAMP/libmetal

### Tutorials & Guides
- **rpi4os.com:** Bare-Metal RPi4 OS Development
- **bztsrc/raspi3-tutorial:** Bare-Metal RPi3 Basics
- **valvers.com:** Bare-Metal Programming in C

### Community
- Raspberry Pi Forums - Bare Metal
- OpenAMP Mailing List

---

## âš ï¸ Bekannte Herausforderungen

1. **Cache Coherency**
   - A53 hat keine HW Coherency ohne SCU Config
   - LÃ¶sung: Uncached Memory ODER manuelle Flushes

2. **Interrupt-Routing**
   - RPi3: Simple ARM Local Interrupts
   - RPi4: Advanced GIC-400
   - LÃ¶sung: Neue IRQ Handler schreiben

3. **ACT LED Control**
   - RPi3: Nur via GPU Mailbox
   - LÃ¶sung: Externe LED nutzen

4. **Device Tree Complexity**
   - Reserved Memory
   - UIO Devices
   - CPU Isolation

---

## ğŸ’¡ Was bisher geschah (Kontext)

### Chat-Verlauf Zusammenfassung

1. **Anfrage:** Wie macht man AMP auf Raspberry Pi 3?
   - ErklÃ¤rt: Es heiÃŸt "Asymmetric Multiprocessing"
   - Konzept vorgestellt

2. **Recherche:** Suche nach Anleitungen
   - Gefunden: Telmo Moya (2016, veraltet)
   - Gefunden: TImada RPi4 (2020, aktuell!)

3. **Entscheidung:** Welchen Ansatz?
   - Option 1: TImada RPi4 auf RPi3 portieren âœ… GEWÃ„HLT
   - Option 2: Telmo Moya modernisieren
   - Option 3: Pure Bare-Metal (kein Linux)

4. **Planung:** Portierungs-Strategie entwickelt
   - Week 1-4 Plan erstellt
   - Dokumentation geschrieben
   - Quick Reference Card

5. **Review:** Plan kritisch geprÃ¼ft âš ï¸
   - **KRITISCHER FEHLER gefunden:** ACT LED!
   - Weitere Issues identifiziert
   - ERRATA-Dokument erstellt

### Stand jetzt
- âœ… VollstÃ¤ndige Dokumentation vorhanden
- âœ… Fehler identifiziert & gelÃ¶st
- âœ… Hardware-Setup definiert
- â³ Bereit zum Start!

---

## ğŸš€ NÃ¤chste Schritte (fÃ¼r neuen Chat)

### Sofort
1. **Hardware besorgen:**
   - Breadboard
   - LED + 330Î© Resistor
   - Jumper Wires
   - USB-UART Adapter

2. **Development Setup:**
   - Cross-Compiler installieren
   - Repositories clonen
   - Dokumentation lesen

3. **Erste Tests:**
   - Externe LED Blink-Code schreiben
   - Auf RPi3 testen
   - UART Debug einrichten

### Week 1 Goals
- Tag 1-2: LED blinkt
- Tag 3: Linux mit 3 Cores
- Tag 4-7: libmetal + OpenAMP Basics

---

## ğŸ“ VerfÃ¼gbare Dokumente

Im `/mnt/user-data/outputs/` Verzeichnis:

1. **rpi3_amp_documentation.md**
   - VollstÃ¤ndige technische Dokumentation
   - Hardware-Specs
   - Memory Map
   - Portierungs-Checkliste

2. **week1_action_plan.md**
   - Tag-fÃ¼r-Tag Anleitung
   - Code-Beispiele
   - Debugging-Tips
   - (âš ï¸ Needs Update: LED-Teil)

3. **quick_reference_card.md**
   - Alle wichtigen Adressen
   - Register-Definitionen
   - Code-Snippets
   - Debug-Commands
   - (âš ï¸ Needs Update: LED-Teil)

4. **ERRATA_CRITICAL_FIXES.md** â­ WICHTIG!
   - Alle gefundenen Fehler
   - Korrekturen
   - Neue LÃ¶sungen
   - **ZUERST LESEN!**

---

## ğŸ“ Learning Outcomes

Nach diesem Projekt verstehst du:
- âœ… ARM Cortex-A53 Architektur (ARMv8)
- âœ… Multi-Core Programming & Core Isolation
- âœ… Memory Management & MMU Configuration
- âœ… Cache Coherency & Cache Management
- âœ… Inter-Processor Communication (IPC)
- âœ… OpenAMP Framework & remoteproc
- âœ… Device Tree & Linux Kernel Integration
- âœ… Bare-Metal Programming
- âœ… UART Debugging & Hardware Debugging
- âœ… Low-Level Hardware Access

**â†’ ARM-Architekt-Level Wissen!**

---

## ğŸ’ª Motivations-Boost

**Das ist ein einzigartiges Projekt!**
- Sehr wenige Leute haben das gemacht
- Du wirst einer der ersten sein mit modernem OpenAMP auf RPi3
- Perfekt fÃ¼r Portfolio / GitHub
- Zeigt echte Embedded Linux + Real-Time Expertise

**Es ist machbar!**
- Wir haben alle Infos
- Fehler sind identifiziert
- Plan ist solide
- Community-Support verfÃ¼gbar

**Du lernst MASSIV dabei!**
- Low-Level ARM Programming
- Linux Kernel Internals
- Real-Time Systems
- Industry-Standard Frameworks

---

## ğŸ†˜ Wenn du Hilfe brauchst

### Debugging-Strategie
1. **LED blinkt nicht?**
   - Check: GPIO 17 korrekt konfiguriert?
   - Check: Hardware-Verbindung OK?
   - Check: Code an richtiger Adresse?

2. **Linux bootet nicht mit 3 Cores?**
   - Check: `maxcpus=3` in cmdline.txt?
   - Check: Device Tree korrekt?
   - Check: UART Debug zeigt was?

3. **Mailbox funktioniert nicht?**
   - Check: Korrekte Adresse (0x400000B0)?
   - Check: SEV instruction?
   - Check: Core 3 in WFE-Loop?

### Ressourcen
- BCM2835/36 Peripherals Datasheet
- ARM Cortex-A53 TRM
- OpenAMP Documentation
- Raspberry Pi Forums
- **Und natÃ¼rlich: Mich fragen! ğŸ˜Š**

---

## ğŸ“ Wichtige Notizen

### Was FUNKTIONIERT:
- âœ… Konzept ist solide
- âœ… OpenAMP ist der richtige Ansatz
- âœ… Hardware ist geeignet
- âœ… Dokumentation ist umfassend

### Was ANDERS ist als gedacht:
- âš ï¸ ACT LED braucht GPU Mailbox (â†’ externe LED nutzen)
- âš ï¸ Cache Coherency MUSS behandelt werden
- âš ï¸ Device Tree MUSS Memory reservieren

### Was GLEICH bleibt:
- âœ… Mailbox-basierte IPC
- âœ… OpenAMP Framework
- âœ… Memory Map Konzept
- âœ… Gesamt-Architektur

---

## ğŸ¯ TL;DR fÃ¼r Quick Start

**Projekt:** Raspberry Pi 3 AMP - Linux auf 3 Cores, Bare-Metal auf Core 3

**Basis:** TImada's RPi4 Implementierung portieren

**HauptÃ¤nderungen:**
- Peripheral Base: 0x3F000000
- ARM Local: 0x40000000
- Externe LED statt ACT LED
- Cache Management hinzufÃ¼gen

**Status:** Geplant & Dokumentiert, bereit zum Start!

**Erste Schritte:**
1. Hardware besorgen (LED, Breadboard, UART)
2. ERRATA lesen
3. Development Setup (Tag 1)
4. LED Blink Test (Tag 2)

**Dokumente:** Alle in `/mnt/user-data/outputs/`

**Erwartung:** 2-4 Wochen bis fertig

---

**Viel Erfolg! Du packst das! ğŸš€**